#!/usr/bin/env python3
"""Playbook CLI: record, test, and list playbook files.

Commands:
    record  --service <s> --flow <f> [--tier <t>]   Record steps by dwell-detection
    test    --service <s> --flow <f> [--tier <t>]   Interactive dry-run
    list                                             Table of all playbooks
"""

import argparse
import json
import math
import os
import select
import subprocess
import sys
import threading
import time

sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..'))

SESSION_FILE = '/tmp/ub-chrome-session.json'


# ------------------------------------------------------------------
# Shared helpers
# ------------------------------------------------------------------

def _load_chrome_session():
    """Load an existing Chrome session from the session file."""
    from agent.browser import BrowserSession

    if not os.path.exists(SESSION_FILE):
        return None

    with open(SESSION_FILE) as f:
        data = json.load(f)

    pid = data['pid']
    try:
        os.kill(pid, 0)
    except OSError:
        return None

    return BrowserSession(
        pid=pid,
        process=None,
        profile_dir=data['profile_dir'],
        window_id=data.get('window_id', 0),
        bounds=data.get('bounds', {}),
    )


def _save_chrome_session(session):
    """Save session state for other CLI tools."""
    data = {
        'pid': session.pid,
        'profile_dir': session.profile_dir,
        'window_id': session.window_id,
        'bounds': session.bounds,
    }
    with open(SESSION_FILE, 'w') as f:
        json.dump(data, f, indent=2)


def _play_sound():
    """Play macOS system sound to indicate a dwell was detected."""
    try:
        subprocess.Popen(
            ['afplay', '/System/Library/Sounds/Tink.aiff'],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )
    except OSError:
        pass


def _playbook_filename(service, flow, tier):
    """Build the playbook filename stem."""
    name = f'{service}_{flow}'
    if tier:
        name += f'_{tier}'
    return name


# ------------------------------------------------------------------
# Dwell detector
# ------------------------------------------------------------------

class DwellDetector:
    """Monitor mouse position at 10Hz, detect dwells (stationary for threshold seconds)."""

    def __init__(self, threshold_sec: float = 3.0, radius_px: float = 5.0):
        self.threshold = threshold_sec
        self.radius = radius_px
        self._lock = threading.Lock()
        self._dwell_position: tuple[int, int] | None = None
        self._running = False
        self._thread: threading.Thread | None = None

    def start(self):
        self._running = True
        self._thread = threading.Thread(target=self._poll_loop, daemon=True)
        self._thread.start()

    def stop(self):
        self._running = False
        if self._thread:
            self._thread.join(timeout=2.0)

    def pop_dwell(self) -> tuple[int, int] | None:
        """Return and clear the last dwell position, or None."""
        with self._lock:
            pos = self._dwell_position
            self._dwell_position = None
            return pos

    def _poll_loop(self):
        import Quartz

        anchor_x, anchor_y = 0, 0
        anchor_time = time.monotonic()
        fired = False

        while self._running:
            event = Quartz.CGEventCreate(None)
            point = Quartz.CGEventGetLocation(event)
            mx, my = int(point.x), int(point.y)

            dist = math.hypot(mx - anchor_x, my - anchor_y)
            if dist > self.radius:
                anchor_x, anchor_y = mx, my
                anchor_time = time.monotonic()
                fired = False
            elif not fired and (time.monotonic() - anchor_time) >= self.threshold:
                with self._lock:
                    self._dwell_position = (mx, my)
                fired = True

            time.sleep(0.1)


# ------------------------------------------------------------------
# record command
# ------------------------------------------------------------------

def _execute_scroll(direction, amount):
    """Actually scroll Chrome so the user can see the effect."""
    from agent.input import scroll as scroll_mod
    from agent.input import window as win_mod
    win_mod.focus_window('Google Chrome')
    time.sleep(0.2)
    scroll_mod.scroll(direction, amount)


def cmd_record(args):
    from agent import browser, screenshot as ss
    from agent.config import (
        PLAYBOOK_DIR,
        PLAYBOOK_REF_DIR,
        RECORD_DWELL_RADIUS_PX,
        RECORD_DWELL_THRESHOLD_SEC,
        VARS_HINT,
    )
    from agent.input import coords

    service = args.service
    flow = args.flow
    tier = args.tier or ''
    pb_name = _playbook_filename(service, flow, tier)

    # Attach to existing Chrome session or open a new one
    session = _load_chrome_session()
    own_session = False
    if session is None:
        print('No active Chrome session. Launching one...')
        session = browser.create_session()
        _save_chrome_session(session)
        own_session = True
        print(f'Chrome launched (PID {session.pid})')
    else:
        browser.get_session_window(session)
        print(f'Attached to Chrome (PID {session.pid})')

    # Ref screenshot dir
    ref_dir = PLAYBOOK_REF_DIR / pb_name
    ref_dir.mkdir(parents=True, exist_ok=True)

    # Start dwell detector
    detector = DwellDetector(
        threshold_sec=RECORD_DWELL_THRESHOLD_SEC,
        radius_px=RECORD_DWELL_RADIUS_PX,
    )
    detector.start()

    steps = []
    step_num = 1
    stashed_tl: tuple[int, int] | None = None  # top-left corner waiting for bottom-right

    print()
    print(f'Recording: {pb_name}')
    print('Hover over elements for 3+ seconds to mark them.')
    print('Type "manual" for steps without dwell (navigate, scroll, wait).')
    print('Type "done" to finish.')
    print()

    def _make_region_from_center(img_x, img_y):
        """10x10 px region centered on dwell point."""
        return [int(img_x) - 5, int(img_y) - 5, int(img_x) + 5, int(img_y) + 5]

    def _make_region_from_corners(tl_img, br_img):
        """Region from top-left and bottom-right image coords."""
        return [int(tl_img[0]), int(tl_img[1]), int(br_img[0]), int(br_img[1])]

    def _save_ref_screenshot(step_n):
        ref_path = ref_dir / f'step_{step_n:02d}.png'
        ss.capture_window(session.window_id, str(ref_path))
        return ref_path

    def _prompt_type_value():
        """Prompt for a value to type, show variable hints. Empty = no typing."""
        print(f'  type? ({VARS_HINT})')
        raw = input('  > ').strip()
        if not raw:
            return None, False
        sens = input('  sensitive? (y/n) [n]: ').strip().lower() == 'y'
        return raw, sens

    def _prompt_description():
        return input('  desc> ').strip()

    def _add_click_step(region, desc, checkpoint=False, cp_prompt=''):
        nonlocal step_num
        step = {
            'step': step_num,
            'action': 'click',
            'target_description': desc,
            'ref_region': region,
            'wait_after_sec': [1, 3],
        }
        if checkpoint:
            step['checkpoint'] = True
            step['checkpoint_prompt'] = cp_prompt
        steps.append(step)
        print(f'  -> Step {step_num}: click "{desc}" region={region}')
        step_num += 1

    def _add_type_step(value, sensitive):
        nonlocal step_num
        # Strip trailing {tab}/{return} for the type_text step
        from agent.playbook import parse_value_and_keys
        clean_value, trailing_keys = parse_value_and_keys(value)

        if clean_value:
            step = {
                'step': step_num,
                'action': 'type_text',
                'value': clean_value,
                'wait_after_sec': [0.5, 1.5],
            }
            if sensitive:
                step['sensitive'] = True
            steps.append(step)
            print(f'  -> Step {step_num}: type_text "{clean_value}"{"  [SENSITIVE]" if sensitive else ""}')
            step_num += 1

        for key in trailing_keys:
            step = {
                'step': step_num,
                'action': 'press_key',
                'value': key,
                'wait_after_sec': [0.3, 0.8],
            }
            steps.append(step)
            print(f'  -> Step {step_num}: press_key "{key}"')
            step_num += 1

    def _handle_dwell(screen_x, screen_y):
        nonlocal stashed_tl

        browser.get_session_window(session)
        img_x, img_y = coords.screen_to_image(screen_x, screen_y, session.bounds)

        print(f'[ding] Dwell at ({int(img_x)}, {int(img_y)}) window-relative')

        if stashed_tl is not None:
            print(f'  (top-left stashed at ({int(stashed_tl[0])}, {int(stashed_tl[1])}))')

        cmd = input(': ').strip().lower()

        if cmd == 'done':
            return 'done'

        if cmd == 'skip':
            return 'continue'

        if cmd == 'tl':
            stashed_tl = (img_x, img_y)
            print(f'  Stashed top-left ({int(img_x)}, {int(img_y)}). Hover over bottom-right now.')
            return 'continue'

        if cmd == 'br':
            if stashed_tl is None:
                print('  No top-left stashed. Use "tl" first.')
                return 'continue'
            region = _make_region_from_corners(stashed_tl, (img_x, img_y))
            stashed_tl = None
            _save_ref_screenshot(step_num)
            desc = _prompt_description()
            if not desc:
                print('  -> Skipped (no description)')
                return 'continue'
            cp = input('  checkpoint? (y/n) [n]: ').strip().lower()
            cp_prompt = ''
            if cp == 'y':
                cp_prompt = input('  checkpoint_prompt: ').strip()
            _add_click_step(region, desc, checkpoint=(cp == 'y'), cp_prompt=cp_prompt)
            # Optional follow-up type
            value, sens = _prompt_type_value()
            if value:
                _add_type_step(value, sens)
            print()
            return 'continue'

        if cmd == 'center':
            region = _make_region_from_center(img_x, img_y)
            stashed_tl = None
            _save_ref_screenshot(step_num)
            desc = _prompt_description()
            if not desc:
                print('  -> Skipped (no description)')
                return 'continue'
            cp = input('  checkpoint? (y/n) [n]: ').strip().lower()
            cp_prompt = ''
            if cp == 'y':
                cp_prompt = input('  checkpoint_prompt: ').strip()
            _add_click_step(region, desc, checkpoint=(cp == 'y'), cp_prompt=cp_prompt)
            # Optional follow-up type
            value, sens = _prompt_type_value()
            if value:
                _add_type_step(value, sens)
            print()
            return 'continue'

        if cmd == 'type':
            region = _make_region_from_center(img_x, img_y)
            stashed_tl = None
            _save_ref_screenshot(step_num)
            desc = _prompt_description()
            if not desc:
                print('  -> Skipped (no description)')
                return 'continue'
            _add_click_step(region, desc)
            # Required type value
            value, sens = _prompt_type_value()
            if value:
                _add_type_step(value, sens)
            else:
                print('  (no value entered, click-only)')
            print()
            return 'continue'

        print(f'  Unknown: "{cmd}". Use: tl, br, center, type, skip, done')
        return 'continue'

    def _handle_manual():
        nonlocal step_num

        print()
        cmd = input('manual> (navigate / scroll / wait / press_key / done): ').strip().lower()

        if cmd == 'done':
            return 'done'

        if cmd == 'navigate':
            url = input('  url: ').strip()
            if url:
                step = {
                    'step': step_num,
                    'action': 'navigate',
                    'url': url,
                    'wait_after_sec': [2, 5],
                }
                steps.append(step)
                print(f'  -> Step {step_num}: navigate "{url}"')
                step_num += 1
            print()
            return 'continue'

        if cmd == 'scroll':
            direction = input('  direction (up/down) [down]: ').strip().lower() or 'down'
            amount_str = input('  amount [3]: ').strip() or '3'
            amount = int(amount_str)
            # Execute the scroll so user can see the result
            print(f'  Scrolling {direction} {amount}...')
            _execute_scroll(direction, amount)
            ok = input('  Good? (y/n/redo) [y]: ').strip().lower()
            while ok == 'redo' or ok == 'n':
                if ok == 'n':
                    amount_str = input('  new amount: ').strip()
                    amount = int(amount_str)
                print(f'  Scrolling {direction} {amount}...')
                _execute_scroll(direction, amount)
                ok = input('  Good? (y/n/redo) [y]: ').strip().lower()
            _save_ref_screenshot(step_num)
            step = {
                'step': step_num,
                'action': 'scroll',
                'target_description': f'{direction} {amount}',
                'wait_after_sec': [0.5, 1.5],
            }
            steps.append(step)
            print(f'  -> Step {step_num}: scroll {direction} {amount}')
            step_num += 1
            print()
            return 'continue'

        if cmd == 'wait':
            lo = input('  wait_sec_low [2]: ').strip() or '2'
            hi = input('  wait_sec_high [4]: ').strip() or '4'
            step = {
                'step': step_num,
                'action': 'wait',
                'wait_after_sec': [float(lo), float(hi)],
            }
            steps.append(step)
            print(f'  -> Step {step_num}: wait [{lo}, {hi}]')
            step_num += 1
            print()
            return 'continue'

        if cmd == 'press_key':
            key = input('  key (enter, tab, escape, ...): ').strip()
            if key:
                step = {
                    'step': step_num,
                    'action': 'press_key',
                    'value': key,
                    'wait_after_sec': [0.3, 0.8],
                }
                steps.append(step)
                print(f'  -> Step {step_num}: press_key "{key}"')
                step_num += 1
            print()
            return 'continue'

        print(f'  Unknown: "{cmd}"')
        print()
        return 'continue'

    try:
        while True:
            dwell = detector.pop_dwell()

            if dwell is not None:
                _play_sound()
                result = _handle_dwell(dwell[0], dwell[1])
                if result == 'done':
                    break

            else:
                readable, _, _ = select.select([sys.stdin], [], [], 0.2)
                if readable:
                    line = sys.stdin.readline().strip().lower()
                    if line == 'done':
                        break
                    if line == 'manual':
                        result = _handle_manual()
                        if result == 'done':
                            break

    finally:
        detector.stop()

    if not steps:
        print('No steps recorded.')
        return

    # Build and write playbook JSON
    playbook_data = {
        'service': service,
        'flow': flow,
        'version': 1,
        'notes': f'Recorded with playbook record on {time.strftime("%Y-%m-%d")}',
        'last_validated': None,
        'steps': steps,
    }
    if tier:
        playbook_data['tier'] = tier

    out_path = PLAYBOOK_DIR / f'{pb_name}.json'
    with open(out_path, 'w') as f:
        json.dump(playbook_data, f, indent=2)
        f.write('\n')

    print()
    print(f'Playbook written: {out_path}')
    print(f'Reference screenshots: {ref_dir}/')
    print(f'{len(steps)} steps recorded.')


# ------------------------------------------------------------------
# test command
# ------------------------------------------------------------------

def cmd_test(args):
    from agent.config import INFERENCE_URL
    from agent.executor import PlaybookExecutor
    from agent.inference import (
        CoordinateInferenceClient,
        HttpInferenceClient,
        MockInferenceClient,
    )
    from agent.playbook import JobContext, Playbook

    service = args.service
    flow = args.flow
    tier = args.tier or ''

    playbook = Playbook.load(service, flow, tier)
    pb_name = _playbook_filename(service, flow, tier)
    print(f'Loaded: {pb_name} v{playbook.version} ({len(playbook.steps)} steps)')
    print(f'Notes: {playbook.notes}')
    print()

    # Select inference client
    if args.coords:
        print('Using CoordinateInferenceClient (recorded ref_region)')
        inference = CoordinateInferenceClient()
    elif args.mock:
        print('Using MockInferenceClient')
        inference = MockInferenceClient()
    else:
        studio_url = os.getenv('STUDIO_URL', INFERENCE_URL)
        try:
            import httpx
            httpx.get(f'{studio_url}/health', timeout=3.0)
            print(f'Using inference server: {studio_url}')
            inference = HttpInferenceClient(base_url=studio_url)
        except Exception:
            print(f'Inference server not reachable ({studio_url}), using mock.')
            inference = MockInferenceClient()

    # Dummy job context for testing
    ctx = JobContext(
        job_id='test-run',
        user_id='test-user',
        service=service,
        flow=flow,
        credentials={
            'email': 'test@example.com',
            'pass': 'testpass123',
            'name': 'Test User',
            'zip': '10001',
            'birth': '01/01/1990',
            'gender': 'other',
            'cc': '4111111111111111',
            'cvv': '123',
            'exp': '12/28',
            'gift': 'TEST-GIFT-CODE',
        },
    )

    # Interactive step callback
    def step_callback(step, session):
        print(f'Step {step.step}/{len(playbook.steps)}: {step.action} "{step.target_description or step.value}"')
        if step.checkpoint and step.checkpoint_prompt:
            print(f'  [checkpoint] "{step.checkpoint_prompt}"')
        if step.is_sensitive:
            print(f'  [sensitive]')
        if step.ref_region:
            print(f'  [ref_region] {list(step.ref_region)}')

        choice = input('Enter=execute, s=skip, q=quit: ').strip().lower()
        if choice == 'q':
            raise KeyboardInterrupt('User quit')
        return choice != 's'

    executor = PlaybookExecutor(inference, step_callback=step_callback)

    print()
    print('Starting interactive test run...')
    print()

    try:
        result = executor.run(playbook, ctx)
    except KeyboardInterrupt:
        print('\nTest run aborted.')
        return

    print()
    print(f'Result: {"SUCCESS" if result.success else "FAILED"}')
    print(f'Duration: {result.duration_seconds}s')
    print(f'Steps: {result.step_count}, Inference calls: {result.inference_count}')
    if result.error_message:
        print(f'Error: {result.error_message}')

    # Update last_validated on success
    if result.success:
        from agent.config import PLAYBOOK_DIR
        pb_path = PLAYBOOK_DIR / f'{pb_name}.json'
        with open(pb_path) as f:
            data = json.load(f)
        data['last_validated'] = time.strftime('%Y-%m-%dT%H:%M:%S')
        with open(pb_path, 'w') as f:
            json.dump(data, f, indent=2)
            f.write('\n')
        print(f'Updated last_validated in {pb_path}')


# ------------------------------------------------------------------
# list command
# ------------------------------------------------------------------

def cmd_list(args):
    from agent.playbook import Playbook

    playbooks = Playbook.list_all()
    if not playbooks:
        print('No playbooks found.')
        return

    print(f'{"Service":<15} {"Flow":<10} {"Tier":<10} {"Ver":>4} {"Steps":>6} {"Last Validated":<20}')
    print('-' * 70)

    for pb in playbooks:
        validated = pb['last_validated'] or 'never'
        print(
            f'{pb["service"]:<15} {pb["flow"]:<10} {pb.get("tier", ""):<10} '
            f'{pb["version"]:>4} {pb["steps"]:>6} {validated:<20}'
        )


# ------------------------------------------------------------------
# main
# ------------------------------------------------------------------

def main():
    parser = argparse.ArgumentParser(description='Playbook recorder, tester, and manager')
    sub = parser.add_subparsers(dest='command')

    p_record = sub.add_parser('record', help='Record a new playbook by walking through a flow')
    p_record.add_argument('--service', required=True, help='Service name (e.g. netflix)')
    p_record.add_argument('--flow', required=True, help='Flow type (signup or cancel)')
    p_record.add_argument('--tier', default='', help='Plan tier (e.g. ads, standard, premium)')

    p_test = sub.add_parser('test', help='Interactive dry-run of a playbook')
    p_test.add_argument('--service', required=True, help='Service name')
    p_test.add_argument('--flow', required=True, help='Flow type')
    p_test.add_argument('--tier', default='', help='Plan tier')
    p_test.add_argument('--mock', action='store_true', help='Force mock inference')
    p_test.add_argument('--coords', action='store_true', help='Use recorded ref_region coordinates')

    sub.add_parser('list', help='List all playbooks')

    args = parser.parse_args()

    if args.command is None:
        parser.print_help()
        sys.exit(1)

    dispatch = {
        'record': cmd_record,
        'test': cmd_test,
        'list': cmd_list,
    }
    dispatch[args.command](args)


if __name__ == '__main__':
    main()
