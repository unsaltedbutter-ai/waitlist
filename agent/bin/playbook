#!/usr/bin/env python3
"""Playbook CLI: record, test, and list playbook files.

Commands:
    record  --service <s> --flow <f>   Walk through a flow, record steps by dwell-detection
    test    --service <s> --flow <f>   Interactive dry-run of an existing playbook
    list                               Table of all playbooks with metadata
"""

import argparse
import json
import math
import os
import subprocess
import sys
import threading
import time

sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..'))

SESSION_FILE = '/tmp/ub-chrome-session.json'


# ------------------------------------------------------------------
# Shared helpers
# ------------------------------------------------------------------

def _load_chrome_session():
    """Load an existing Chrome session from the session file."""
    from agent.browser import BrowserSession

    if not os.path.exists(SESSION_FILE):
        return None

    with open(SESSION_FILE) as f:
        data = json.load(f)

    pid = data['pid']
    try:
        os.kill(pid, 0)
    except OSError:
        return None

    return BrowserSession(
        pid=pid,
        process=None,
        profile_dir=data['profile_dir'],
        window_id=data.get('window_id', 0),
        bounds=data.get('bounds', {}),
    )


def _save_chrome_session(session):
    """Save session state for other CLI tools."""
    data = {
        'pid': session.pid,
        'profile_dir': session.profile_dir,
        'window_id': session.window_id,
        'bounds': session.bounds,
    }
    with open(SESSION_FILE, 'w') as f:
        json.dump(data, f, indent=2)


def _play_sound():
    """Play macOS system sound to indicate a dwell was detected."""
    try:
        subprocess.Popen(
            ['afplay', '/System/Library/Sounds/Tink.aiff'],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )
    except OSError:
        pass


# ------------------------------------------------------------------
# record command
# ------------------------------------------------------------------

class DwellDetector:
    """Monitor mouse position at 10Hz, detect dwells (stationary for threshold seconds)."""

    def __init__(self, threshold_sec: float = 3.0, radius_px: float = 5.0):
        self.threshold = threshold_sec
        self.radius = radius_px
        self._lock = threading.Lock()
        self._dwell_position: tuple[int, int] | None = None
        self._running = False
        self._thread: threading.Thread | None = None

    def start(self):
        self._running = True
        self._thread = threading.Thread(target=self._poll_loop, daemon=True)
        self._thread.start()

    def stop(self):
        self._running = False
        if self._thread:
            self._thread.join(timeout=2.0)

    def pop_dwell(self) -> tuple[int, int] | None:
        """Return and clear the last dwell position, or None."""
        with self._lock:
            pos = self._dwell_position
            self._dwell_position = None
            return pos

    def _poll_loop(self):
        import Quartz

        anchor_x, anchor_y = 0, 0
        anchor_time = time.monotonic()
        fired = False

        while self._running:
            event = Quartz.CGEventCreate(None)
            point = Quartz.CGEventGetLocation(event)
            mx, my = int(point.x), int(point.y)

            dist = math.hypot(mx - anchor_x, my - anchor_y)
            if dist > self.radius:
                # Mouse moved, reset anchor
                anchor_x, anchor_y = mx, my
                anchor_time = time.monotonic()
                fired = False
            elif not fired and (time.monotonic() - anchor_time) >= self.threshold:
                # Dwell detected
                with self._lock:
                    self._dwell_position = (mx, my)
                fired = True

            time.sleep(0.1)  # 10Hz


def _prompt_step_details(action: str, step_num: int) -> dict | None:
    """Interactive prompts for step metadata based on action type."""
    step = {'step': step_num, 'action': action}

    if action == 'click':
        desc = input('  target_description: ').strip()
        if not desc:
            return None
        step['target_description'] = desc
        cp = input('  checkpoint? (y/n) [n]: ').strip().lower()
        if cp == 'y':
            step['checkpoint'] = True
            step['checkpoint_prompt'] = input('  checkpoint_prompt: ').strip()
        wait = input('  wait_after_sec [1,3]: ').strip()
        if wait:
            parts = [float(x.strip()) for x in wait.split(',')]
            step['wait_after_sec'] = parts[:2] if len(parts) >= 2 else [parts[0], parts[0] + 1]
        else:
            step['wait_after_sec'] = [1, 3]

    elif action == 'type_text':
        desc = input('  target_description: ').strip()
        if not desc:
            return None
        step['target_description'] = desc
        step['value'] = input('  value (e.g. {user_email}): ').strip()
        sens = input('  sensitive? (y/n) [n]: ').strip().lower()
        if sens == 'y':
            step['sensitive'] = True
        step['wait_after_sec'] = [0.5, 1.5]

    elif action == 'navigate':
        url = input('  url: ').strip()
        if not url:
            return None
        step['url'] = url
        step['wait_after_sec'] = [2, 5]

    elif action == 'scroll':
        direction = input('  direction (up/down) [down]: ').strip() or 'down'
        amount = input('  amount [3]: ').strip() or '3'
        step['target_description'] = f'{direction} {amount}'
        step['wait_after_sec'] = [0.5, 1.5]

    elif action == 'checkpoint':
        step['action'] = 'click'  # checkpoints attach to an action
        step['checkpoint'] = True
        step['checkpoint_prompt'] = input('  checkpoint_prompt: ').strip()
        step['target_description'] = input('  target_description (what to click after): ').strip()
        step['wait_after_sec'] = [1, 3]

    elif action == 'select_plan':
        desc = input('  target_description (plan name): ').strip()
        if not desc:
            return None
        step['target_description'] = desc
        step['checkpoint'] = True
        step['checkpoint_prompt'] = input('  checkpoint_prompt: ').strip()
        step['wait_after_sec'] = [2, 4]

    elif action == 'select_payment_method':
        desc = input('  target_description (payment option): ').strip()
        if not desc:
            return None
        step['target_description'] = desc
        step['wait_after_sec'] = [1, 3]

    elif action == 'handle_retention':
        desc = input('  target_description: ').strip()
        if not desc:
            return None
        step['target_description'] = desc
        step['checkpoint'] = True
        step['checkpoint_prompt'] = input('  checkpoint_prompt: ').strip()
        step['may_repeat'] = True
        max_r = input('  max_repeats [5]: ').strip() or '5'
        step['max_repeats'] = int(max_r)
        step['wait_after_sec'] = [2, 4]

    elif action == 'verify_success':
        step['checkpoint'] = True
        step['checkpoint_prompt'] = input('  checkpoint_prompt: ').strip()
        step['target_description'] = input('  target_description: ').strip()
        step['wait_after_sec'] = [2, 4]

    elif action == 'wait':
        lo = input('  wait_sec_low [2]: ').strip() or '2'
        hi = input('  wait_sec_high [4]: ').strip() or '4'
        step['wait_after_sec'] = [float(lo), float(hi)]

    elif action == 'press_key':
        key = input('  key (e.g. enter, tab, escape): ').strip()
        if not key:
            return None
        step['value'] = key
        step['wait_after_sec'] = [0.5, 1.5]

    else:
        print(f'  Unknown action: {action}')
        return None

    return step


def cmd_record(args):
    from agent import browser, screenshot as ss
    from agent.config import PLAYBOOK_DIR, PLAYBOOK_REF_DIR, RECORD_DWELL_RADIUS_PX, RECORD_DWELL_THRESHOLD_SEC
    from agent.input import coords, window

    service = args.service
    flow = args.flow

    # Attach to existing Chrome session or open a new one
    session = _load_chrome_session()
    own_session = False
    if session is None:
        print('No active Chrome session. Launching one...')
        session = browser.create_session()
        _save_chrome_session(session)
        own_session = True
        print(f'Chrome launched (PID {session.pid})')
    else:
        # Refresh bounds
        browser.get_session_window(session)
        print(f'Attached to Chrome (PID {session.pid})')

    # Ref screenshot dir
    ref_dir = PLAYBOOK_REF_DIR / f'{service}_{flow}'
    ref_dir.mkdir(parents=True, exist_ok=True)

    # Start dwell detector
    detector = DwellDetector(
        threshold_sec=RECORD_DWELL_THRESHOLD_SEC,
        radius_px=RECORD_DWELL_RADIUS_PX,
    )
    detector.start()

    steps = []
    step_num = 1

    print()
    print(f'Recording: {service} {flow}')
    print('Hover over elements for 3+ seconds to mark them.')
    print('Type "manual" at the prompt for steps without dwell (navigate, scroll, wait).')
    print('Type "done" to finish recording.')
    print()

    try:
        while True:
            # Check for dwell
            dwell = detector.pop_dwell()

            if dwell is not None:
                screen_x, screen_y = dwell
                _play_sound()

                # Get window-relative coords
                browser.get_session_window(session)
                img_x, img_y = coords.screen_to_image(screen_x, screen_y, session.bounds)

                # Save reference screenshot
                ref_path = ref_dir / f'step_{step_num:02d}.png'
                ss.capture_window(session.window_id, str(ref_path))

                print(f'[ding] Dwell at ({int(img_x)}, {int(img_y)}) window-relative')
                print(f'Screenshot: {ref_path}')
                print()

                action = input(
                    'Action? (click / type_text / select_plan / select_payment_method / '
                    'handle_retention / verify_success / checkpoint / skip / done): '
                ).strip().lower()

                if action == 'done':
                    break
                if action == 'skip':
                    continue

                step_data = _prompt_step_details(action, step_num)
                if step_data is not None:
                    steps.append(step_data)
                    print(f'  -> Step {step_num} recorded ({action})')
                    step_num += 1
                else:
                    print('  -> Skipped (incomplete input)')
                print()

            else:
                # No dwell, check for manual input (non-blocking via timeout)
                # We poll: check stdin if there's a manual command
                import select
                readable, _, _ = select.select([sys.stdin], [], [], 0.2)
                if readable:
                    line = sys.stdin.readline().strip().lower()
                    if line == 'done':
                        break
                    if line == 'manual':
                        print()
                        action = input(
                            'Manual action? (navigate / scroll / wait / press_key / done): '
                        ).strip().lower()
                        if action == 'done':
                            break
                        step_data = _prompt_step_details(action, step_num)
                        if step_data is not None:
                            # Save reference screenshot for manual steps too
                            ref_path = ref_dir / f'step_{step_num:02d}.png'
                            ss.capture_window(session.window_id, str(ref_path))
                            steps.append(step_data)
                            print(f'  -> Step {step_num} recorded ({action})')
                            step_num += 1
                        else:
                            print('  -> Skipped (incomplete input)')
                        print()

    finally:
        detector.stop()

    if not steps:
        print('No steps recorded.')
        return

    # Build playbook JSON
    playbook_data = {
        'service': service,
        'flow': flow,
        'version': 1,
        'last_validated': None,
        'notes': f'Recorded with playbook record on {time.strftime("%Y-%m-%d")}',
        'steps': steps,
    }

    out_path = PLAYBOOK_DIR / f'{service}_{flow}.json'
    with open(out_path, 'w') as f:
        json.dump(playbook_data, f, indent=2)
        f.write('\n')

    print(f'Playbook written: {out_path}')
    print(f'Reference screenshots: {ref_dir}/')
    print(f'{len(steps)} steps recorded.')


# ------------------------------------------------------------------
# test command
# ------------------------------------------------------------------

def cmd_test(args):
    from agent.config import INFERENCE_URL
    from agent.executor import PlaybookExecutor
    from agent.inference import HttpInferenceClient, MockInferenceClient
    from agent.playbook import JobContext, Playbook

    service = args.service
    flow = args.flow

    playbook = Playbook.load(service, flow)
    print(f'Loaded: {service}_{flow} v{playbook.version} ({len(playbook.steps)} steps)')
    print(f'Notes: {playbook.notes}')
    print()

    # Use real inference if STUDIO_URL is set and reachable, otherwise mock
    use_mock = args.mock
    if not use_mock:
        studio_url = os.getenv('STUDIO_URL', INFERENCE_URL)
        try:
            import httpx
            httpx.get(f'{studio_url}/health', timeout=3.0)
            print(f'Using inference server: {studio_url}')
            inference = HttpInferenceClient(base_url=studio_url)
        except Exception:
            print(f'Inference server not reachable ({studio_url}), using mock.')
            use_mock = True

    if use_mock:
        print('Using MockInferenceClient')
        inference = MockInferenceClient()

    # Dummy job context for testing
    ctx = JobContext(
        job_id='test-run',
        user_id='test-user',
        service=service,
        flow=flow,
        credentials={
            'email': 'test@example.com',
            'password': 'testpass123',
            'card_number': '4111111111111111',
            'card_expiry': '12/28',
            'card_cvv': '123',
        },
        gift_card_code='TEST-GIFT-CODE',
        billing_zip='10001',
    )

    # Interactive step callback
    def step_callback(step, session):
        print(f'Step {step.step}/{len(playbook.steps)}: {step.action} "{step.target_description}"')
        if step.checkpoint and step.checkpoint_prompt:
            print(f'  [checkpoint] Will verify: "{step.checkpoint_prompt}"')
        if step.is_sensitive:
            print(f'  [sensitive] Value will not be logged')

        choice = input('Press Enter to execute, "s" to skip, "q" to quit: ').strip().lower()
        if choice == 'q':
            raise KeyboardInterrupt('User quit')
        return choice != 's'

    executor = PlaybookExecutor(inference, step_callback=step_callback)

    print()
    print('Starting interactive test run...')
    print()

    try:
        result = executor.run(playbook, ctx)
    except KeyboardInterrupt:
        print('\nTest run aborted by user.')
        return

    print()
    print(f'Result: {"SUCCESS" if result.success else "FAILED"}')
    print(f'Duration: {result.duration_seconds}s')
    print(f'Steps: {result.step_count}, Inference calls: {result.inference_count}')
    if result.error_message:
        print(f'Error: {result.error_message}')

    # Update last_validated on success
    if result.success:
        from agent.config import PLAYBOOK_DIR
        pb_path = PLAYBOOK_DIR / f'{service}_{flow}.json'
        with open(pb_path) as f:
            data = json.load(f)
        data['last_validated'] = time.strftime('%Y-%m-%dT%H:%M:%S')
        with open(pb_path, 'w') as f:
            json.dump(data, f, indent=2)
            f.write('\n')
        print(f'Updated last_validated in {pb_path}')


# ------------------------------------------------------------------
# list command
# ------------------------------------------------------------------

def cmd_list(args):
    from agent.playbook import Playbook

    playbooks = Playbook.list_all()
    if not playbooks:
        print('No playbooks found.')
        return

    # Table header
    print(f'{"Service":<15} {"Flow":<10} {"Ver":>4} {"Steps":>6} {"Last Validated":<20}')
    print('-' * 60)

    for pb in playbooks:
        validated = pb['last_validated'] or 'never'
        print(
            f'{pb["service"]:<15} {pb["flow"]:<10} {pb["version"]:>4} '
            f'{pb["steps"]:>6} {validated:<20}'
        )


# ------------------------------------------------------------------
# main
# ------------------------------------------------------------------

def main():
    parser = argparse.ArgumentParser(description='Playbook recorder, tester, and manager')
    sub = parser.add_subparsers(dest='command')

    p_record = sub.add_parser('record', help='Record a new playbook by walking through a flow')
    p_record.add_argument('--service', required=True, help='Service name (e.g. netflix)')
    p_record.add_argument('--flow', required=True, help='Flow type (signup or cancel)')

    p_test = sub.add_parser('test', help='Interactive dry-run of a playbook')
    p_test.add_argument('--service', required=True, help='Service name')
    p_test.add_argument('--flow', required=True, help='Flow type')
    p_test.add_argument('--mock', action='store_true', help='Force mock inference (skip server check)')

    sub.add_parser('list', help='List all playbooks')

    args = parser.parse_args()

    if args.command is None:
        parser.print_help()
        sys.exit(1)

    dispatch = {
        'record': cmd_record,
        'test': cmd_test,
        'list': cmd_list,
    }
    dispatch[args.command](args)


if __name__ == '__main__':
    main()
