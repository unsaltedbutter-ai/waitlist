# Red Team Security Analysis: UnsaltedButter.ai

Generated 2026-02-28.

## Executive Summary

This analysis covers the VPS (Next.js + PostgreSQL + BTCPay), orchestrator (Python + Nostr), and agent (Python + Chrome automation) components. The codebase demonstrates strong security hygiene in many areas (parameterized queries, HMAC with nonce/timestamp, AES-256-GCM, timing-safe comparisons, CSP headers, OTP redaction). The most significant risks are architectural: the co-location of the encryption key with encrypted credentials on the same VPS, and the plaintext credential transit over HTTPS to the LAN agent.

---

## CRITICAL Findings

### C-1. Encryption Key and Encrypted Data Co-Located on VPS

**Files**: `web/src/lib/crypto.ts` (lines 10-18), `scripts/deploy.sh` (line 172)

The encryption keyfile lives at `~/.unsaltedbutter/encryption.keyfile` on the same VPS that stores the encrypted streaming credentials in PostgreSQL. If an attacker gains shell access, root access, or even read access to the keyfile path, they can decrypt every stored email and password in the database with a trivial script.

**Attack vector**: VPS compromise via any path (SSH key theft, Next.js RCE, dependency supply chain, PM2 exploit, unpatched kernel). Attacker reads keyfile + dumps DB = full credential exfiltration for all users.

**Current mitigation**: chmod 600 on keyfile, non-root `butter` user, file-based key (not env var). These are good hygiene but do not protect against process-level compromise.

**Recommendation**:
1. Move decryption to the home LAN (orchestrator or agent). The VPS would store encrypted blobs and never hold the key.
2. If decryption must stay on VPS, use an HSM or KMS (e.g., a Yubikey-backed PKCS#11 or age-based envelope encryption with a second key on the orchestrator could add a layer).
3. At minimum, ensure the Next.js process runs with a dedicated user that has read access to the keyfile, separate from the `butter` user that owns the deployment.

---

### C-2. Plaintext Credentials Returned Over HTTPS API

**File**: `web/src/app/api/agent/credentials/[npub]/[service]/route.ts` (lines 59-62)

The agent credential endpoint decrypts credentials and returns them as plaintext JSON over HTTPS. While HMAC-authenticated and the agent is on the home LAN calling through the internet, this means:
- Plaintext credentials traverse the public internet (VPS to home LAN via HTTPS).
- TLS termination at nginx means the Next.js process handles plaintext in memory.
- Any TLS interception (certificate mismatch, CA compromise) exposes all credentials.

**Attack vector**: MITM on the VPS-to-orchestrator HTTPS path, or compromise of the orchestrator machine which now holds plaintext credentials in memory.

**Current mitigation**: HMAC auth prevents unauthorized callers. TLS encrypts in transit. Active job check prevents arbitrary credential fetches.

**Recommendation**:
1. Implement end-to-end encryption: encrypt credentials with the agent's public key (Nostr key or a dedicated X25519 key). The VPS never sees plaintext.
2. Pin the VPS TLS certificate in the orchestrator's httpx client to prevent MITM.

---

## HIGH Findings

### H-1. In-Memory Rate Limiter and Replay Protection Reset on PM2 Restart

**Files**: `web/src/lib/rate-limit.ts` (lines 17-48), `web/src/lib/agent-auth.ts` (lines 9-12), `web/src/app/api/auth/nostr/route.ts` (line 10)

All rate limiting, nonce tracking, and Nostr event replay protection use in-memory Maps. PM2 restarts (which happen on deploy, crash, or max memory restart at 512MB) clear all state. An attacker could:
- Trigger a PM2 restart (e.g., by sending many large requests to hit the 512M memory limit) to reset rate limiters.
- Replay previously captured HMAC-signed requests (the nonce store is cleared).
- Replay Nostr auth events (the consumed events map is cleared).

**Attack vector**: Attacker captures a valid HMAC request or Nostr auth event. Triggers a PM2 restart. Replays the captured request within the timestamp window (60s for HMAC, 300s for Nostr auth).

**Current mitigation**: Single PM2 instance (no multi-process split-brain). Timestamp window limits replay window. nginx rate limiting provides a secondary layer (10 req/s with burst 20).

**Recommendation**:
1. Move nonce tracking to PostgreSQL or a lightweight on-disk store (SQLite). The query is simple: `INSERT INTO nonces (nonce, expires_at) VALUES ($1, NOW() + INTERVAL '2 minutes') ON CONFLICT DO NOTHING RETURNING nonce`.
2. For rate limiting, PostgreSQL-backed counters or at minimum a persistent file-backed store.

---

### H-2. JWT Has No Revocation Mechanism

**File**: `web/src/lib/auth.ts` (lines 11-16)

JWTs are valid for 24 hours with no server-side revocation. If a user's token is stolen (XSS on a third-party site that reads localStorage, or browser extension malware), the attacker has full access for up to 24 hours. There is no logout endpoint that invalidates the token server-side; the client-side `logout()` just removes from localStorage.

**Attack vector**: Token theft via malicious browser extension or XSS on a domain that can read localStorage. Attacker uses stolen token to read credentials (email only, not password via GET /api/credentials), create jobs, or modify account.

**Current mitigation**: CSP header blocks third-party scripts. Token stored in localStorage (accessible to JS). 24h expiry limits window.

**Recommendation**:
1. Add a `token_issued_at` column to the users table. On logout or password-change-equivalent, update it. Reject JWTs issued before that timestamp.
2. Reduce token expiry to 1-4 hours with a silent refresh mechanism.
3. Consider httpOnly cookies instead of localStorage for token storage (prevents JS access entirely).

---

### H-3. Email Hash Is Unsalted SHA-256 (Rainbow Table Vulnerable)

**File**: `web/src/lib/crypto.ts` (lines 54-57)

The `hashEmail` function uses unsalted SHA-256. Email addresses have low entropy (common domains like gmail.com, yahoo.com). An attacker with database read access (SQL injection, backup theft, or VPS compromise) could reverse these hashes using precomputed rainbow tables for common email patterns or known email lists from data breach compilations.

These hashes are stored in `reneged_emails.email_hash` and `jobs.email_hash`.

**Current mitigation**: The hash is only used for blocklist checking (not authentication). The actual encrypted email is in `streaming_credentials.email_enc`.

**Recommendation**: Use HMAC-SHA256 with a server-side secret (the encryption key or a dedicated pepper) instead of plain SHA-256. This prevents rainbow table attacks even if the database is exfiltrated without the key.

---

### H-4. OTP Code Brute-Force if Rate Limiter Resets

**Files**: `web/src/app/api/agent/otp/route.ts` (line 30), `web/src/app/api/auth/nostr/route.ts`

A 12-digit numeric OTP has 10^12 possibilities (~40 bits of entropy). The OTP login endpoint is rate-limited to 5 attempts per 15 minutes per IP, but the rate limit is in-memory and resets on PM2 restart (see H-1).

**Current mitigation**: IP-based rate limiting (5/15min). OTP consumed on use (single-use). SHA-256 hashed in database.

**Recommendation**:
1. Add a per-npub rate limit on OTP verification attempts (not just per-IP), stored in PostgreSQL.
2. Implement exponential backoff on failed OTP attempts for the same npub_hex.
3. The current 12-digit length is reasonable if rate limiting is reliable. Fix H-1 first.

---

## MEDIUM Findings

### M-1. No CSRF Protection on State-Changing Endpoints

**Files**: `web/src/app/api/credentials/route.ts`, `web/src/app/api/on-demand/route.ts`

All state-changing endpoints rely solely on Bearer token auth. Since tokens are stored in localStorage and sent via `Authorization` header (not cookies), traditional CSRF via form submission is not a concern. However, if a future change moves tokens to cookies, CSRF would immediately become exploitable.

**Current mitigation**: Bearer token in Authorization header (not auto-sent by browser). CSP `form-action 'self'` prevents cross-origin form posts.

**Recommendation**: Document this as a security invariant: tokens must never be moved to cookies without adding CSRF protection. Consider adding an `X-Requested-With` header check as defense-in-depth.

---

### M-2. Nostr Auth Event Lacks Domain Binding

**Files**: `web/src/app/api/auth/nostr/route.ts` (lines 37-60), `web/src/app/login/page.tsx` (lines 100-104)

The signed Nostr event has no domain-specific challenge or tag. If another service uses the same kind 22242 pattern (NIP-42 auth), a signed event from that service could potentially be replayed here (within the 5-minute window). The `content` field is not validated server-side.

**Current mitigation**: 5-minute expiry. Replay protection (consumed event IDs). The specific `kind: 22242` with `content: "Sign in to UnsaltedButter"` is somewhat domain-specific.

**Recommendation**: Add a server-generated challenge. The flow should be:
1. Client calls `GET /api/auth/challenge` to receive a random challenge string.
2. Client signs an event with `tags: [["challenge", challengeString], ["relay", "unsaltedbutter.ai"]]`.
3. Server validates the challenge exists and has not been consumed.

---

### M-3. BTCPay API Key Stored in .env.production (Same VPS)

**Files**: `scripts/deploy.sh` (lines 175-177), `web/src/lib/btcpay-invoice.ts` (lines 19-21)

The BTCPay API key is stored in `.env.production` on the same VPS that runs BTCPay. This key can create invoices, verify payment status, and potentially (depending on permissions) manage the Lightning node. VPS compromise = BTCPay API key compromise.

**Current mitigation**: chmod 600 on .env.production. BTCPay API key scoped to specific permissions (presumably). BTCPay runs in Docker with its own isolation.

**Recommendation**:
1. Use the most restrictive BTCPay API key permissions possible (invoice creation and read only, no wallet management).
2. Store the API key in a file (like the Nostr key), not in .env.production, with stricter filesystem permissions.
3. Implement withdrawal limits or cold storage in the LND configuration.

---

### M-4. Backup Files Contain Full Database Dumps with Encrypted Credentials

**File**: `scripts/backup-daily.sh` (line 13)

Daily backups create full pg_dump files containing all encrypted credentials. These are synced offsite to a Hetzner Storage Box. If the Storage Box is compromised and the encryption key is also obtained, all credentials are exposed.

**Current mitigation**: Backups are gzipped (not encrypted at rest). chmod 600 on backup files. Storage Box uses SSH key auth. 14-day retention (limits exposure window).

**Recommendation**:
1. Encrypt backups with GPG/age before offsite sync, using a key stored separately from the VPS.
2. Consider excluding the `streaming_credentials` table from offsite backups entirely (credentials can be re-entered by users).

---

### M-5. Agent-Orchestrator Communication Is Unauthenticated on LAN

**Architecture**: Agent and orchestrator communicate over LAN HTTP without authentication.

If an attacker gains access to the home LAN (WiFi compromise, IoT device compromise, visitor access), they can intercept credential data being passed from orchestrator to agent, send fake job commands, or exfiltrate screenshots/automation state.

**Current mitigation**: LAN-only access. No internet exposure. The orchestrator validates jobs via VPS API before dispatching.

**Recommendation**:
1. Add mTLS or a shared secret between orchestrator and agent.
2. Use a VLAN or firewall rules to isolate the automation machines from the rest of the home network.

---

### M-6. Error Messages in Action Logs Could Contain Sensitive Data

**File**: `web/src/app/api/agent/jobs/[id]/action-log/route.ts` (lines 55-56)

The `error_message` field is stored directly in the database without sanitization. If the agent encounters an error that includes credential fragments, URLs with tokens, or user data in exception messages, this could leak sensitive information into the action_logs table.

**Current mitigation**: The agent controls what it sends. OTP redaction exists in the orchestrator's message log but not in action_log error messages.

**Recommendation**: Add a sanitization function for `error_message` that strips email addresses, URLs with query parameters, and anything matching credential patterns before storage.

---

### M-7. pushAutoInvite Sends OTP Through Nostr Relays

**File**: `web/src/lib/nostr-push.ts` (lines 210-216)

OTP codes are sent from VPS to orchestrator via NIP-17 gift-wrapped DMs through public Nostr relays. While NIP-17 provides end-to-end encryption, the relays store the encrypted events. If the orchestrator's Nostr private key is compromised, an attacker could decrypt historical relay messages and extract OTP codes (though they expire in 15 minutes).

**Current mitigation**: NIP-17 gift wrap encryption. OTPs expire in 15 minutes. OTPs are single-use (consumed on verification).

**Recommendation**: Acceptable risk given the short TTL and single-use nature. Ensure the orchestrator's Nostr private key is stored securely (file-based, chmod 600).

---

## LOW Findings

### L-1. CSP Allows 'unsafe-inline' for Scripts

**File**: `web/next.config.ts` (line 35)

The Content Security Policy allows `'unsafe-inline'` for both scripts and styles. This weakens XSS protection. Next.js requires inline scripts for hydration, making this difficult to avoid without a nonce-based CSP.

**Current mitigation**: No user-generated content is rendered as HTML. All API responses are JSON. React's JSX escaping prevents stored XSS.

**Recommendation**: When feasible, migrate to nonce-based CSP. Next.js 14+ supports this via experimental settings.

---

### L-2. No Token Binding or Device Fingerprinting

**File**: `web/src/lib/auth.ts` (lines 11-16)

JWT tokens contain only `sub` (userId), `iat`, and `exp`. No IP address, user agent, or device fingerprint is bound to the token. A stolen token works from any device or location.

**Current mitigation**: 24h expiry. Bearer auth (not cookies, so harder to steal via CSRF).

**Recommendation**: Consider adding IP binding or at minimum logging token usage from unexpected IPs for alerting.

---

### L-3. Operator Auth Relies on Single OPERATOR_USER_ID Env Var

**File**: `web/src/lib/operator-auth.ts` (lines 8-10, 32-34)

If `OPERATOR_USER_ID` is not set, `resolveOperatorId()` returns null, and the check correctly blocks all access. This is safe-by-default. However, a single user ID as the operator means no multi-admin support and no audit trail distinguishing between operators.

**Current mitigation**: Single operator (intentional for solo-operated service).

**Recommendation**: Acceptable for current scale. If multiple operators are ever needed, move to a roles table.

---

### L-4. Database Password Stored in Plaintext File

**File**: `scripts/deploy.sh` (line 152)

The PostgreSQL password is stored in a plaintext file at `~/.unsaltedbutter/db_password`.

**Current mitigation**: PostgreSQL is bound to localhost only. The `butter` user has limited shell access.

**Recommendation**: Consider PostgreSQL peer authentication (no password needed for local connections) to eliminate the stored password entirely.

---

### L-5. No Input Length Limits on Credential Storage

**File**: `web/src/app/api/credentials/route.ts` (lines 14-16)

No maximum length validation on `email` or `password` fields. An attacker could submit very large strings (megabytes) that would be encrypted and stored, consuming database space and encryption CPU time.

**Current mitigation**: nginx `client_max_body_size` defaults to 1MB. Authentication required.

**Recommendation**: Add explicit length limits (e.g., email < 320 chars, password < 1024 chars).

---

### L-6. No Lockfile Integrity Check in Deployment

**File**: `scripts/deploy.sh` (line 425)

`npm ci` respects `package-lock.json` integrity hashes, which is good. However, there is no explicit check that the lockfile has not been tampered with before running `npm ci` on the VPS.

**Current mitigation**: The lockfile is synced from the git repo via rsync. Git commit history provides provenance. `npm ci` itself verifies integrity hashes.

**Recommendation**: Low risk. For additional hardening, consider running `npm audit` in the deploy pipeline.

---

## Positive Security Observations

1. **Parameterized queries everywhere**: All SQL uses `$1, $2` placeholders via `pg`. No string concatenation. Orchestrator SQLite uses `?` with column name whitelist (`_ALLOWED_JOB_COLUMNS`).
2. **HMAC auth is solid**: Timestamp + nonce + method + path + body hash, with timing-safe comparison. Signature verified before nonce consumed.
3. **AES-256-GCM with random IV**: Correct authenticated encryption. Unique IV per encryption. Key length validated.
4. **OTP codes hashed before storage**: SHA-256 hash stored in DB, plaintext never persisted.
5. **OTP redaction in logs**: Orchestrator's `_redact_sensitive()` catches digit-only messages before they reach the message log.
6. **Nostr private key in file, not env var**: Prevents exposure in process listing, error dumps, or env-logging middleware.
7. **Security headers**: CSP, X-Frame-Options DENY, X-Content-Type-Options nosniff, HSTS with preload, Permissions-Policy, COOP.
8. **Pre-flight deploy checks**: chmod 600 validation, key file existence checks.
9. **Credential fetch requires active job**: Agent credential endpoint verifies an active job exists before returning credentials.
10. **BTCPay webhook signature verification**: Uses HMAC-SHA256 with timing-safe comparison, then double-checks via BTCPay API.

---

## Risk Summary Table

| ID | Severity | Finding | Exploitability |
|----|----------|---------|----------------|
| C-1 | Critical | Encryption key co-located with encrypted data | Requires VPS compromise |
| C-2 | Critical | Plaintext credentials in transit over HTTPS | Requires MITM or orchestrator compromise |
| H-1 | High | In-memory rate limiting resets on restart | PM2 restart + replay |
| H-2 | High | No JWT revocation mechanism | Token theft + 24h window |
| H-3 | High | Unsalted SHA-256 email hashing | DB exfiltration + rainbow table |
| H-4 | High | OTP brute-force if rate limiter resets | Dependent on H-1 |
| M-1 | Medium | No CSRF protection (safe now, fragile) | Future regression risk |
| M-2 | Medium | Nostr auth event lacks domain binding | Cross-service replay |
| M-3 | Medium | BTCPay API key in .env.production | Requires VPS compromise |
| M-4 | Medium | Unencrypted backup files with credential data | Requires backup storage compromise |
| M-5 | Medium | Unauthenticated LAN communication | Requires LAN access |
| M-6 | Medium | Unsanitized error messages in action logs | Accidental data leak |
| M-7 | Medium | OTP transit through Nostr relays | Requires orchestrator key compromise + short window |
| L-1 | Low | CSP allows unsafe-inline | Weakens XSS mitigation |
| L-2 | Low | No token binding | Token theft from any device |
| L-3 | Low | Single operator ID, no multi-admin | Scale limitation |
| L-4 | Low | DB password in plaintext file | Requires VPS read access |
| L-5 | Low | No input length limits on credentials | DoS via large payloads |
| L-6 | Low | No explicit lockfile tamper check | Supply chain risk |
